
// Copyright (C) 2023-2025 Cognizant Digital Business, Evolutionary AI.
// All Rights Reserved.
// Issued under the Academic Public License.
//
// You can be released from the terms, and requirements of the Academic Public
// License by purchasing a commercial license.
// Purchase of a commercial license is mandatory for any use of the
// neuro-san SDK Software in commercial settings.
//
// END COPYRIGHT

// To obtain information concerning the code generation that is used by this Interface Definition Language
// please see the following:
//
// Go - https://developers.google.com/protocol-buffers/docs/reference/go-generated
// Python - https://developers.google.com/protocol-buffers/docs/reference/python-generated
//
syntax = "proto3";

package dev.cognizant_ai.neuro_san.api.grpc.agent;

import "google/protobuf/struct.proto";
import "neuro_san/api/grpc/chat.proto";

option go_package = "github.com/leaf-ai/neuro_san/internal/gen/dev.cognizant_ai/neuro_san/api/grpc/agent/v1;agent";


// The service comprises all the exchanges to the backend in support of a single agent's
// services.  Routing is done by way of agent name on the grpc service hosting the agent,
// so as to keep info about which agents are hosted private (grpc gives the hand when a
// particular agent is unknown.
service AgentService {

    // Called when a client needs the function description of an agent.
    rpc Function (FunctionRequest) returns (FunctionResponse) {}

    // Called when the user needs to initialize a new chat request
    // or respond to an LLM's request during an already initialized chat.
    // NOTE: This method is deprecated in favor of StreamingChat
    rpc Chat (ChatRequest) returns (ChatResponse) {}

    // Polls for chat results which are processed asynchronously from Chat() above.
    // NOTE: This method is deprecated in favor of StreamingChat
    rpc Logs (LogsRequest) returns (LogsResponse) {}

    // Resets the chat initiated with Chat() above.
    // NOTE: This method is deprecated in favor of StreamingChat
    rpc Reset (ResetRequest) returns (ResetResponse) {}

    // Unidirectional streaming method which would supercede Chat() and Logs() above.
    // Most important semantics of the streaming:
    //  1) The "answer" to a query of any agent network is the *last* streamed
    //     AI message whose origin list is of length 1 - this indicates it is from
    //     the FrontMan of the agent network.
    //  2) To RESTfully continue your conversation with the agent network:
    //     The very last AGENT_FRAMEWORK message before the stream closes will
    //     have its chat_context field filled in with a structure. You can
    //     copy this whole-cloth to the chat_context of your next StreamingChat
    //     request to continue the conversation.
    rpc StreamingChat(ChatRequest) returns (stream ChatResponse) {}

    // Called when a client needs the internal connectivity description of an agent.
    rpc Connectivity(ConnectivityRequest) returns (ConnectivityResponse) {}
}

enum AgentStatus {
    // The status is unknown.  Very rare.
    UNKNOWN = 0;

    // The given session_id is alive and well
    // on this service instance and the gRPC method
    // can functionally proceed with a valid result.
    FOUND = 1;

    // Returned if the service instance does not find
    // the session_id given in the request.
    // For continuing chat streams, this could imply
    // a series of client-side retries as multiple
    // service instances will not keep track of the same
    // assistants.
    NOT_FOUND = 2;

    // Returned when no session_id was given (initiation
    // of new chat by client) and a new assistant is created.
    // This is only ever returned by Chat()
    // and this is an indication that the client should retain
    // the returned session_id to pursue further conversation.
    CREATED = 3;
}

// Request structure for Function gRPC method
message FunctionRequest {
}

// Description of an agent's function
message Function {

    // Outward-facing description of what the agent does.
    string description = 1 [json_name="description"];

    // Optional map of parameters that the agent needs in order to work.
    // This is really a pydantic/OpenAI function description, which is
    // a bit too complex to specify directly in protobuf.
    google.protobuf.Struct parameters = 2 [json_name="parameters"];
}

// Response structure for Function gRPC method
message FunctionResponse {

    // The functional description of the agent.
    // Any initial chat prompt is obtained from the Function's description.
    Function function = 1 [json_name="function"];

    // Enum describing the status
    // See the definition of the Status enum above for details
    // on how to respond.
    AgentStatus status = 2;
}

// Request structure for Chat gRPC method
message ChatRequest {

    // A string UUID identifying the root ownership of the chat assistant's resources.
    // Upon first contact this can be blank, as the client does not yet possess
    // the right information.
    string session_id = 1 [json_name="session_id"];

    // User input to initiate or continue the chat
    string user_input = 2 [json_name="user_input"];

    // This is an entirely optional map whose keys refer to data that is better
    // left out of the LLM chat stream.  The keys themselves might appear in the
    // chat stream, referring to the data, but the data itself does not.
    // The intent is for the key references to be passed to tools,
    // which then grab the values by programmatic means.
    google.protobuf.Struct sly_data = 3 [json_name="sly_data"];

    // Supercedes user_input above
    chat.ChatMessage user_message = 4 [json_name="user_message"];

    // Supercedes session_id above.
    // Message for holding the state of play for any chat session
    // such that should the client send this back to the service,
    // a different server knows exactly where to pick up where the previous
    // conversation left off. There are 2 uses:
    //  1)  When this is not present in the request, a completely new conversation
    //      is initiated.
    //  2)  To RESTfully continue an existing conversation: The last AGENT_FRAMEWORK
    //      message that was streamed from your previous StreamingChat() call
    //      will have its chat_context field filled in its ChatMessage.
    //      Simply take the value there and put it here for your next request
    //      to continue the conversation (your new user_input adding to the exchange).
    //      No client-side parsing of the ChatContext is explicitly required.
    chat.ChatContext chat_context = 5 [json_name="chat_context"];
}

// Response structure for Chat gRPC method
message ChatResponse {

    // The request that generated this response
    ChatRequest request = 1;

    // A string UUID identifying the root ownership of the chat assistant's resources.
    string session_id = 2 [json_name="session_id"];

    // Enum describing the status of the given session_id
    // See the definition of the AgentStatus enum above for details
    // on how to respond.
    AgentStatus status = 3;

    // Optionally returned.
    // Idea is that all of the above come back immediately to establish
    // the connection, but likely the field below would not initially be filled in.
    // Later on, as messages return from agents, later streamed versions of this
    // message would have response below filled in with single messages from
    // specific agents any time any one of them has something new to say.
    // The origin info on the ChatMessage would allow the client to place
    // just where in the agent hierarchy the message comes from.
    // (Think like a URI:
    //  opportunity_finder_pipeline/opportunity_finder_process_manager/synthetic_data_generator)
    chat.ChatMessage response = 4 [json_name="response"];
}

// Request structure for Logs gRPC method
message LogsRequest {

    // A string UUID identifying the root ownership of the chat assistant's resources.
    // When calling Logs(), this cannot be blank.
    string session_id = 1 [json_name="session_id"];
}

// Response structure for Logs gRPC method
message LogsResponse {

    // The request that generated this response
    LogsRequest request = 1;

    // A string UUID identifying the root ownership of the chat assistant's resources.
    string session_id = 2 [json_name="session_id"];

    // Enum describing the status of the given session_id
    // See the definition of the AgentStatus enum above for details
    // on how to respond.
    AgentStatus status = 3;

    // A single string representing the most recent chat response
    string chat_response = 4 [json_name="chat_response"];

    // A list of strings representing the "thought process" logs thus far.
    repeated string logs = 5;
}


// Request structure for Reset gRPC method
message ResetRequest {

    // A string UUID identifying the root ownership of the chat assistant's resources.
    // When calling Reset(), this cannot be blank.
    string session_id = 1 [json_name="session_id"];
}

// Response structure for Reset gRPC method
message ResetResponse {

    // The request that generated this response
    ResetRequest request = 1;

    // A string UUID identifying the root ownership of the chat assistant's resources.
    string session_id = 2 [json_name="session_id"];

    // Enum describing the status of the given session_id
    // See the definition of the AgentStatus enum above for details
    // on how to respond.
    AgentStatus status = 3;
}

// Request structure for Connectivity gRPC method
message ConnectivityRequest {
}

message ConnectivityInfo {

    // The agent network node whose connectivity is being described
    string origin = 1 [json_name="origin"];

    // A list of tool nodes that are possible to reach from the origin
    //
    // This might include references into external agent networks, perhaps hosted
    // on other servers.  Separate calls to those guys will need to be made
    // in order to gain information about their own connectivity, if this is
    // actually desired by the client.
    //
    // Worth noting that server-side agent descriptions are allowed to
    // withhold connectivity info they deem private, or too much of an
    // implementation detail.  That is, connectivity reported is only
    // as much as the server wants a client to know.
    repeated string tools = 2 [json_name="tools"];
}


// Response structure for Connectivity gRPC method
message ConnectivityResponse {

    // The description of the agent network's internal connectivity
    // ... as far as the agent wants the outside world to know..
    repeated ConnectivityInfo connectivity_info = 1 [json_name="connectivity_info"];

    // Enum describing the status
    // See the definition of the Status enum above for details
    // on how to respond.
    AgentStatus status = 2;
}

